1.1 Общее о классах

new - оператор, создающий новый экземпляр класса. Например class ShopProduct{ внутри него  нужно создать экземпляр, $product = new ShopPorduct();};

Public, private и protected - определяет область видимости (scope) пременной внутри класса. 

public - к общедоступным свойствам и методам можно получить доступ из любого контекста.
private - доступ можно получить только из того класса, в котором они (свойства и методы) объявлены. 
protected - доступ можно получить либо из класса содержащий их, либо из наследованного класса.

**++**Чем может быть полезно ограничение доступа методов и свойств? Ключевые слова, показывают только те аспекты, которые требуются клиенту. Контроль доступа, поможет избежать оишибок в коде 

--Проблема--.Нужно сделать метод outputAddresses () строгим в отношении
типа данных аргумента $resolve.
function outputAddresses ( $resolve ) {
  if ( ! is_bool ( $ resolve ) ) {
  die( "Методу outputAddress() требуется булев аргумент\n" ) ;
  }
} 

Разделять отвецсвенность классов, класс ShopProduct - хранит данные о товаре, а класс ShopProductWriter - за вывод этих данных.

Уточнение типов данных класса. Если нужно нужно уточнить какой именно тип класса должен быть передан. Например для класса ShopProductWriter() должжен быть передан калсс типа ShopProduct, иначе код будет рабоать некоректно.
Уточняеться тип: public function write(/*тип передаваемого аргумента*/ ShopProduct  /*сам аргумент*/ $shopProduct){
	
} 


1.2 Наследование

Это механизм, при котором из одного (родительского) класса можно получить много (дочерних) подклассов. Дочерний класс наследует свойтва и методы, базового класса, а так же добавляет новые функциональне возможности.
Наследование помогает решить проблему "все в одном классе", создавая новый подкласс. Базовый класс не будет обладать избыточной информацией, что облегчит его понимание. 
Дочерние классы наследуют доступ ко всем методам типа pubic и protected родительского класса (но не к методам и свойствам типа private). 

Первый шаг при построении дерева наследования - найти элементы базового класса, которые не соответствуют дург к другу или которыми нужно оперировать инче.

Опертор instanceof ( если объект в операнде слева относится
к типу. представляемому операндом справа) тогда true. Пример: if ($shopProduct instanceof CDProduct ).

Чтобы обратиться к методу в контексте класса, а не объекта, следует использовать символы "::". а не "->". Поэтому конструкция parent :: _construct () означает следующее: "Вызвать мeтoд _ construct () родительского класса".

Статические методы и свойства satic private $someVar; Они не могут получать доступа ни к каким обычным свйствам класса, потому что такие свойства принадлежать объектам. Все это делаеться для разграничения между классои и объектом.
Из статических методов можно обращатья к статическим свойствам. И если изменить статическое свойство, то все экземпляры этого класса смогут получить доступ к новому занчению.

Абстрактные классы

Экземпляр абстрактного класса нельзя создать. Вместо этого в нем определяется (и. возможно, частично реализуется) интерфейс для любого класса, который может его расширить. 
Например: 
abstract class ShopProductWriter {
	protected $products = array();
	
	public function addProduct(ShopProduct $shopProduct){
		$this ->products[] = $shopPorduct;
	}
}

Абстрактный метод, создаеться в абстрактным классе и должен быть вызван у наследников абстрактного класса, иначе будет ошибка.
Абстрактный класс нужен, когда нужно семейство классов, у которых есть много общего. Конечно, можно применить и интерфейс, но тогда нужно будет писать много идентичного кода.

Пример: Абстрактный класс заведомо не будет запрошен как объект. К примеру абстрактный класс - Транспорт: Но все его наследники будут Автомобилем, краном, лодкой, самолет и т.д. 
Например вы заведомо знаете, что весь транспорт будет двигаться. И вы объявляете абстрактный метод(движение) в абстрактном классе, который нужен будет 100% всем наследникам т.е. без движения это уже не транспорт и новый наследник обязан будет реализовать это. 
В самом же абстрактном классе, есть другие поля и свойства, которые будут унаследованы. Ну например мощность двигателя(очень грубо), или то что их роднит.

Интерфейсы
С помощью интерфейса можно можно только определить функциональность, но не реализовать ее. Объявление интерфейса - ключевое слово interface. 
В интерфейсе могут находиться только объявления методов, но не тела этих методов. 
Например: 
//объявление интерфейса

interface Chargeable {
	puЬlic function getPrice (); 
}

//реализация интерфейса

class ShopProduct implements Chargeabe{
	pubic function getPrice (){
		return ( $this->price - $this->discount ); 
	}
}

После ключевого слова implements можно перечислить через запятую несколько интерфейсов.

class Consultancy extends TimedService implements ВооkаЫе, ChargeaЫe { 
	// code...	
}

В РНР поддерживается только наследование от одного родителя (так называемое одиночное наследование), поэтому после ключевого слова extends можно указать только одно имя базового класса.

Трейты
Терйты нужны если нужно реализовать ряд общих методов для всей иерархии наследования классов, например: Есть какой-то класс, который наследуется от базового/абстрактного класса, дополнительно ему нужно унаследовать еще функционал, от другого класса. Нужно использовать терйт.
Решают проблему дублирования кода, при наследовании классов.

Несмотря на то что полезность применения трейтов не вызывает особых сомнений, они не позволяют изменить тип класса, в который были включены.
Поэтому, если трейт IdentityTrait используется сразу в нескольких классах, у вас не будет общего типа, который можно было бы указать в уточнениях для сигнатур методов.
К счастью, трейты можно успешно использовать вместе с интерфейсами. Мы можем определить интерфейс с сигнатурой метода generateid (), а затем указать, что в классе ShopProduct реализуются методы этого интерфейса. 

// Использование статических методов в трейте 

trait PriceUtilities {
	private static $taxrate = 17;
	static function calculateTax( $price){
		return ( (self::$taxrate/100) * $price);
	}	
}

abstract class Service {
	// Базоввый класс для службы сервиса
}

class UtilityService extends Service {
	use PriceUtilities;
}

$u = new UtilityService();
print $u::calculateTax( 100 )."\n";  // 17

// Использование абстактных методов в трейте
При использование таккого трейте в классе в нем должны быть реализованы все объявленные в трейте абстактные методы.

trait PriceUtilities {
	function calculateTax( $price){
		return ( (self::$taxrate/100) * $price);
	}

	abstract function getTaxRate();
}
abstract class Service {
	// Базоввый класс для службы сервиса
}

class UtilityService extends Service {
	use PriceUtilities;
	function getTaxRate(){
		return 17;
	}
}

$u = new UtilityService();
print $u->calculateTax( 100 ). "\n";  // 17
	
Устанение конфликтов в имени методов трейтов. Например у терйтов TaxTools и PriceUtilities может быть одинакова назван метод function calculateTax(), пир вызове  этого метода в классе, использующий такой метод, возникнет ошибка (Fatal error). 
Для устранения этой проблемы используется ключевое слово insteadof. Слева от него указывается полностью определенное имя метода состоящее из имени трейта и имени метода. В правой части конструкции insteadof указывается
имя трейта, метод которого с аналогичным именем должен быть заменен. 
